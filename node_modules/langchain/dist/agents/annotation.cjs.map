{"version":3,"file":"annotation.cjs","names":["middlewareList: TMiddleware","zodSchema: Record<string, any>","z","MessagesZodMeta","PreHookAnnotation: AnnotationRoot<{\n  llmInputMessages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n  messages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n}>","_x: Messages","update: Messages"],"sources":["../../src/agents/annotation.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v3\";\nimport {\n  Messages,\n  AnnotationRoot,\n  MessagesZodMeta,\n  type BinaryOperatorAggregate,\n} from \"@langchain/langgraph\";\nimport { withLangGraph } from \"@langchain/langgraph/zod\";\n\nimport type { AgentMiddleware } from \"./middleware/types.js\";\n\nexport function createAgentAnnotationConditional<\n  TMiddleware extends readonly AgentMiddleware<any, any, any>[] = []\n>(\n  hasStructuredResponse = true,\n  middlewareList: TMiddleware = [] as unknown as TMiddleware\n) {\n  /**\n   * Create Zod schema object to preserve jsonSchemaExtra\n   * metadata for LangGraph Studio using v3-compatible withLangGraph\n   */\n  const zodSchema: Record<string, any> = {\n    messages: withLangGraph(z.custom<BaseMessage[]>(), MessagesZodMeta),\n    jumpTo: z\n      .union([z.literal(\"model_request\"), z.literal(\"tools\"), z.undefined()])\n      .optional(),\n  };\n\n  /**\n   * Add middleware state properties to the Zod schema\n   */\n  for (const middleware of middlewareList) {\n    if (middleware.stateSchema) {\n      const { shape } = middleware.stateSchema;\n      for (const [key, schema] of Object.entries(shape)) {\n        /**\n         * Skip private state properties\n         */\n        if (key.startsWith(\"_\")) {\n          continue;\n        }\n\n        if (!(key in zodSchema)) {\n          zodSchema[key] = schema;\n        }\n      }\n    }\n  }\n\n  // Only include structuredResponse when responseFormat is defined\n  if (hasStructuredResponse) {\n    zodSchema.structuredResponse = z.any().optional();\n  }\n\n  return z.object(zodSchema);\n}\n\nexport const PreHookAnnotation: AnnotationRoot<{\n  llmInputMessages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n  messages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n}> = z.object({\n  llmInputMessages: withLangGraph(z.custom<BaseMessage[]>(), {\n    reducer: {\n      fn: (_x: Messages, update: Messages) =>\n        MessagesZodMeta.reducer!.fn([], update),\n    },\n    default: () => [],\n  }),\n  /**\n   * Use MessagesZodMeta to preserve jsonSchemaExtra metadata\n   * for LangGraph Studio UI to render proper messages input field\n   */\n  messages: withLangGraph(z.custom<BaseMessage[]>(), MessagesZodMeta),\n}) as unknown as AnnotationRoot<{\n  llmInputMessages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n  messages: BinaryOperatorAggregate<BaseMessage[], Messages>;\n}>;\nexport type PreHookAnnotation = typeof PreHookAnnotation;\n"],"mappings":";;;;;;AAaA,SAAgB,iCAGd,wBAAwB,MACxBA,iBAA8B,CAAE,GAChC;;;;;CAKA,MAAMC,YAAiC;EACrC,uDAAwBC,SAAE,QAAuB,EAAEC,sCAAgB;EACnE,QAAQD,SACL,MAAM;GAACA,SAAE,QAAQ,gBAAgB;GAAEA,SAAE,QAAQ,QAAQ;GAAEA,SAAE,WAAW;EAAC,EAAC,CACtE,UAAU;CACd;;;;AAKD,MAAK,MAAM,cAAc,eACvB,KAAI,WAAW,aAAa;EAC1B,MAAM,EAAE,OAAO,GAAG,WAAW;AAC7B,OAAK,MAAM,CAAC,KAAK,OAAO,IAAI,OAAO,QAAQ,MAAM,EAAE;;;;AAIjD,OAAI,IAAI,WAAW,IAAI,CACrB;AAGF,OAAI,EAAE,OAAO,YACX,UAAU,OAAO;EAEpB;CACF;AAIH,KAAI,uBACF,UAAU,qBAAqBA,SAAE,KAAK,CAAC,UAAU;AAGnD,QAAOA,SAAE,OAAO,UAAU;AAC3B;AAED,MAAaE,oBAGRF,SAAE,OAAO;CACZ,+DAAgCA,SAAE,QAAuB,EAAE;EACzD,SAAS,EACP,IAAI,CAACG,IAAcC,WACjBH,sCAAgB,QAAS,GAAG,CAAE,GAAE,OAAO,CAC1C;EACD,SAAS,MAAM,CAAE;CAClB,EAAC;CAKF,uDAAwBD,SAAE,QAAuB,EAAEC,sCAAgB;AACpE,EAAC"}