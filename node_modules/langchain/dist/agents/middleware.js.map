{"version":3,"file":"middleware.js","names":["config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `beforeAgent` hook.\n   */\n  beforeAgentJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `beforeModel` hook.\n   */\n  beforeModelJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `afterModel` hook.\n   */\n  afterModelJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `afterAgent` hook.\n   */\n  afterAgentJumpTo?: JumpToTarget[];\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: (ClientTool | ServerTool)[];\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCall to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request.toolCall);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request.toolCall);\n   * }\n   * ```\n   */\n  wrapToolCall?: (\n    request: ToolCallRequest<\n      (TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}) &\n        AgentBuiltInState,\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >,\n    handler: ToolCallHandler\n  ) => Promise<ToolMessage | Command> | ToolMessage | Command;\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: (\n    request: ModelRequest<\n      (TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}) &\n        AgentBuiltInState,\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >,\n    handler: (\n      request: ModelRequest<\n        (TSchema extends InteropZodObject\n          ? InferInteropZodInput<TSchema>\n          : {}) &\n          AgentBuiltInState,\n        TContextSchema extends InteropZodObject\n          ? InferInteropZodOutput<TContextSchema>\n          : TContextSchema extends InteropZodDefault<any>\n          ? InferInteropZodOutput<TContextSchema>\n          : TContextSchema extends InteropZodOptional<any>\n          ? Partial<InferInteropZodOutput<TContextSchema>>\n          : never\n      >\n    ) => Promise<AIMessage> | AIMessage\n  ) => Promise<AIMessage> | AIMessage;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n}","middleware: AgentMiddleware<TSchema, TContextSchema, any>"],"sources":["../../src/agents/middleware.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  InteropZodObject,\n  InteropZodDefault,\n  InteropZodOptional,\n  InferInteropZodInput,\n  InferInteropZodOutput,\n} from \"@langchain/core/utils/types\";\nimport type { AIMessage, ToolMessage } from \"@langchain/core/messages\";\nimport type { Command } from \"@langchain/langgraph\";\n\nimport type { JumpToTarget } from \"./constants.js\";\nimport type { ClientTool, ServerTool } from \"./tools.js\";\nimport type { Runtime, AgentBuiltInState } from \"./runtime.js\";\nimport type {\n  AgentMiddleware,\n  MiddlewareResult,\n  ToolCallRequest,\n  ToolCallHandler,\n} from \"./middleware/types.js\";\nimport type { ModelRequest } from \"./nodes/types.js\";\n/**\n * Creates a middleware instance with automatic schema inference.\n *\n * @param config - Middleware configuration\n * @param config.name - The name of the middleware\n * @param config.stateSchema - The schema of the middleware state\n * @param config.contextSchema - The schema of the middleware context\n * @param config.wrapModelCall - The function to wrap model invocation\n * @param config.wrapToolCall - The function to wrap tool invocation\n * @param config.beforeModel - The function to run before the model call\n * @param config.afterModel - The function to run after the model call\n * @param config.beforeAgent - The function to run before the agent execution starts\n * @param config.afterAgent - The function to run after the agent execution completes\n * @returns A middleware instance\n *\n * @example\n * ```ts\n * const authMiddleware = createMiddleware({\n *   name: \"AuthMiddleware\",\n *   stateSchema: z.object({\n *     isAuthenticated: z.boolean().default(false),\n *   }),\n *   contextSchema: z.object({\n *     userId: z.string(),\n *   }),\n *   beforeModel: async (state, runtime, controls) => {\n *     if (!state.isAuthenticated) {\n *       return controls.terminate(new Error(\"Not authenticated\"));\n *     }\n *   },\n * });\n * ```\n */\nexport function createMiddleware<\n  TSchema extends InteropZodObject | undefined = undefined,\n  TContextSchema extends\n    | InteropZodObject\n    | InteropZodOptional<InteropZodObject>\n    | InteropZodDefault<InteropZodObject>\n    | undefined = undefined\n>(config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `beforeAgent` hook.\n   */\n  beforeAgentJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `beforeModel` hook.\n   */\n  beforeModelJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `afterModel` hook.\n   */\n  afterModelJumpTo?: JumpToTarget[];\n  /**\n   * Explitictly defines which targets are allowed to be jumped to from the `afterAgent` hook.\n   */\n  afterAgentJumpTo?: JumpToTarget[];\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: (ClientTool | ServerTool)[];\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCall to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request.toolCall);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request.toolCall);\n   * }\n   * ```\n   */\n  wrapToolCall?: (\n    request: ToolCallRequest<\n      (TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}) &\n        AgentBuiltInState,\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >,\n    handler: ToolCallHandler\n  ) => Promise<ToolMessage | Command> | ToolMessage | Command;\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: (\n    request: ModelRequest<\n      (TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}) &\n        AgentBuiltInState,\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >,\n    handler: (\n      request: ModelRequest<\n        (TSchema extends InteropZodObject\n          ? InferInteropZodInput<TSchema>\n          : {}) &\n          AgentBuiltInState,\n        TContextSchema extends InteropZodObject\n          ? InferInteropZodOutput<TContextSchema>\n          : TContextSchema extends InteropZodDefault<any>\n          ? InferInteropZodOutput<TContextSchema>\n          : TContextSchema extends InteropZodOptional<any>\n          ? Partial<InferInteropZodOutput<TContextSchema>>\n          : never\n      >\n    ) => Promise<AIMessage> | AIMessage\n  ) => Promise<AIMessage> | AIMessage;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: (\n    state: (TSchema extends InteropZodObject\n      ? InferInteropZodInput<TSchema>\n      : {}) &\n      AgentBuiltInState,\n    runtime: Runtime<\n      TContextSchema extends InteropZodObject\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodDefault<any>\n        ? InferInteropZodOutput<TContextSchema>\n        : TContextSchema extends InteropZodOptional<any>\n        ? Partial<InferInteropZodOutput<TContextSchema>>\n        : never\n    >\n  ) =>\n    | Promise<\n        MiddlewareResult<\n          Partial<\n            TSchema extends InteropZodObject\n              ? InferInteropZodInput<TSchema>\n              : {}\n          >\n        >\n      >\n    | MiddlewareResult<\n        Partial<\n          TSchema extends InteropZodObject ? InferInteropZodInput<TSchema> : {}\n        >\n      >;\n}): AgentMiddleware<TSchema, TContextSchema, any> {\n  const middleware: AgentMiddleware<TSchema, TContextSchema, any> = {\n    name: config.name,\n    stateSchema: config.stateSchema,\n    contextSchema: config.contextSchema,\n    beforeAgentJumpTo: config.beforeAgentJumpTo,\n    beforeModelJumpTo: config.beforeModelJumpTo,\n    afterModelJumpTo: config.afterModelJumpTo,\n    afterAgentJumpTo: config.afterAgentJumpTo,\n    tools: config.tools ?? [],\n  };\n\n  if (config.wrapToolCall) {\n    middleware.wrapToolCall = async (request, handler) =>\n      Promise.resolve(config.wrapToolCall!(request, handler));\n  }\n\n  if (config.wrapModelCall) {\n    middleware.wrapModelCall = async (request, handler) =>\n      Promise.resolve(config.wrapModelCall!(request, handler));\n  }\n\n  if (config.beforeAgent) {\n    middleware.beforeAgent = async (state, runtime) =>\n      Promise.resolve(\n        config.beforeAgent!(\n          state,\n          runtime as Runtime<\n            TContextSchema extends InteropZodObject\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodDefault<any>\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodOptional<any>\n              ? Partial<InferInteropZodOutput<TContextSchema>>\n              : never\n          >\n        )\n      );\n  }\n\n  if (config.beforeModel) {\n    middleware.beforeModel = async (state, runtime) =>\n      Promise.resolve(\n        config.beforeModel!(\n          state,\n          runtime as Runtime<\n            TContextSchema extends InteropZodObject\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodDefault<any>\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodOptional<any>\n              ? Partial<InferInteropZodOutput<TContextSchema>>\n              : never\n          >\n        )\n      );\n  }\n\n  if (config.afterModel) {\n    middleware.afterModel = async (state, runtime) =>\n      Promise.resolve(\n        config.afterModel!(\n          state,\n          runtime as Runtime<\n            TContextSchema extends InteropZodObject\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodDefault<any>\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodOptional<any>\n              ? Partial<InferInteropZodOutput<TContextSchema>>\n              : never\n          >\n        )\n      );\n  }\n\n  if (config.afterAgent) {\n    middleware.afterAgent = async (state, runtime) =>\n      Promise.resolve(\n        config.afterAgent!(\n          state,\n          runtime as Runtime<\n            TContextSchema extends InteropZodObject\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodDefault<any>\n              ? InferInteropZodOutput<TContextSchema>\n              : TContextSchema extends InteropZodOptional<any>\n              ? Partial<InferInteropZodOutput<TContextSchema>>\n              : never\n          >\n        )\n      );\n  }\n\n  return middleware;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA,SAAgB,iBAOdA,QAqTgD;CAChD,MAAMC,aAA4D;EAChE,MAAM,OAAO;EACb,aAAa,OAAO;EACpB,eAAe,OAAO;EACtB,mBAAmB,OAAO;EAC1B,mBAAmB,OAAO;EAC1B,kBAAkB,OAAO;EACzB,kBAAkB,OAAO;EACzB,OAAO,OAAO,SAAS,CAAE;CAC1B;AAED,KAAI,OAAO,cACT,WAAW,eAAe,OAAO,SAAS,YACxC,QAAQ,QAAQ,OAAO,aAAc,SAAS,QAAQ,CAAC;AAG3D,KAAI,OAAO,eACT,WAAW,gBAAgB,OAAO,SAAS,YACzC,QAAQ,QAAQ,OAAO,cAAe,SAAS,QAAQ,CAAC;AAG5D,KAAI,OAAO,aACT,WAAW,cAAc,OAAO,OAAO,YACrC,QAAQ,QACN,OAAO,YACL,OACA,QASD,CACF;AAGL,KAAI,OAAO,aACT,WAAW,cAAc,OAAO,OAAO,YACrC,QAAQ,QACN,OAAO,YACL,OACA,QASD,CACF;AAGL,KAAI,OAAO,YACT,WAAW,aAAa,OAAO,OAAO,YACpC,QAAQ,QACN,OAAO,WACL,OACA,QASD,CACF;AAGL,KAAI,OAAO,YACT,WAAW,aAAa,OAAO,OAAO,YACpC,QAAQ,QACN,OAAO,WACL,OACA,QASD,CACF;AAGL,QAAO;AACR"}