{"version":3,"file":"types.d.cts","names":["InteropZodObject","InteropZodType","START","END","StateGraph","LanguageModelLike","BaseMessage","BaseCheckpointSaver","BaseStore","Messages","ResponseFormat","ToolStrategy","TypedToolStrategy","ProviderStrategy","JsonSchemaFormat","ResponseFormatUndefined","AgentMiddleware","AnyAnnotationRoot","ServerTool","ClientTool","JumpToTarget","N","Interrupt","TValue","BuiltInState","UserInput","ToolCall","Record","ToolResult","JumpTo","ExecutedToolCall","CreateAgentParams","StructuredResponseType","ContextSchema","ResponseFormatType","AbortSignal","ExtractZodArrayTypes","T","Rest","A","WithStateGraphNodes","Graph","SD","S","U","K","I","O","C"],"sources":["../../src/agents/types.d.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InteropZodObject, InteropZodType } from \"@langchain/core/utils/types\";\nimport type { START, END, StateGraph } from \"@langchain/langgraph\";\nimport type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseCheckpointSaver, BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport type { Messages } from \"@langchain/langgraph/\";\nimport type { ResponseFormat, ToolStrategy, TypedToolStrategy, ProviderStrategy, JsonSchemaFormat, ResponseFormatUndefined } from \"./responses.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot } from \"./middleware/types.js\";\nimport type { ServerTool, ClientTool } from \"./tools.js\";\nimport type { JumpToTarget } from \"./constants.js\";\nexport type N = typeof START | \"model_request\" | \"tools\";\n/**\n * Represents information about an interrupt.\n */\nexport interface Interrupt<TValue = unknown> {\n    /**\n     * The ID of the interrupt.\n     */\n    id: string;\n    /**\n     * The requests for human input.\n     */\n    value: TValue;\n}\nexport interface BuiltInState {\n    messages: BaseMessage[];\n    __interrupt__?: Interrupt[];\n    /**\n     * Optional property to control routing after afterModel middleware execution.\n     * When set by middleware, the agent will jump to the specified node instead of\n     * following normal routing logic. The property is automatically cleared after use.\n     *\n     * - \"model_request\": Jump back to the model for another LLM call\n     * - \"tools\": Jump to tool execution (requires tools to be available)\n     */\n    jumpTo?: JumpToTarget;\n}\n/**\n * Base input type for `.invoke` and `.stream` methods.\n */\nexport type UserInput = {\n    messages: Messages;\n};\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ToolCall {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, any>;\n    /**\n     * The result of the tool call.\n     */\n    result?: unknown;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * Information about a tool result from a tool execution.\n */\nexport interface ToolResult {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The result of the tool call.\n     */\n    result: any;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * jump targets (internal)\n */\nexport type JumpTo = \"model_request\" | \"tools\" | typeof END;\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ExecutedToolCall {\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, unknown>;\n    /**\n     * The ID of the tool call.\n     */\n    tool_id: string;\n    /**\n     * The result of the tool call (if available).\n     */\n    result?: unknown;\n}\nexport type CreateAgentParams<StructuredResponseType extends Record<string, any> = Record<string, any>, ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot, ResponseFormatType = InteropZodType<StructuredResponseType> | InteropZodType<unknown>[] | JsonSchemaFormat | JsonSchemaFormat[] | ResponseFormat | TypedToolStrategy<StructuredResponseType> | ToolStrategy<StructuredResponseType> | ProviderStrategy<StructuredResponseType> | ResponseFormatUndefined> = {\n    /**\n     * Defines a model to use for the agent. You can either pass in an instance of a LangChain chat model\n     * or a string. If a string is provided the agent initializes a ChatModel based on the provided model name and provider.\n     * It supports various model providers and allows for runtime configuration of model parameters.\n     *\n     * @uses {@link initChatModel}\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-7-sonnet-latest\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example\n     * ```ts\n     * import { ChatOpenAI } from \"@langchain/openai\";\n     * const agent = createAgent({\n     *   model: new ChatOpenAI({ model: \"gpt-4o\" }),\n     *   // ...\n     * });\n     * ```\n     */\n    model: string | LanguageModelLike;\n    /**\n     * A list of tools or a ToolNode.\n     *\n     * @example\n     * ```ts\n     * import { tool } from \"langchain\";\n     *\n     * const weatherTool = tool(() => \"Sunny!\", {\n     *   name: \"get_weather\",\n     *   description: \"Get the weather for a location\",\n     *   schema: z.object({\n     *     location: z.string().describe(\"The location to get weather for\"),\n     *   }),\n     * });\n     *\n     * const agent = createAgent({\n     *   tools: [weatherTool],\n     *   // ...\n     * });\n     * ```\n     */\n    tools?: (ServerTool | ClientTool)[];\n    /**\n     * An optional system message for the model.\n     */\n    systemPrompt?: string;\n    /**\n     * An optional schema for the context. It allows to pass in a typed context object into the agent\n     * invocation and allows to access it in hooks such as `prompt` and middleware.\n     * As opposed to the agent state, defined in `stateSchema`, the context is not persisted between\n     * agent invocations.\n     *\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   llm: model,\n     *   tools: [getWeather],\n     *   contextSchema: z.object({\n     *     capital: z.string(),\n     *   }),\n     *   prompt: (state, config) => {\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. The capital of France is ${config.context.capital}.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new SystemMessage(\"You are a helpful assistant.\"),\n     *     new HumanMessage(\"What is the capital of France?\"),\n     *   ],\n     * }, {\n     *   context: {\n     *     capital: \"Paris\",\n     *   },\n     * });\n     * ```\n     */\n    contextSchema?: ContextSchema;\n    /**\n     * An optional checkpoint saver to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/persistence | Checkpointing}\n     */\n    checkpointer?: BaseCheckpointSaver | boolean;\n    /**\n     * An optional store to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Long-term memory}\n     */\n    store?: BaseStore;\n    /**\n     * An optional schema for the final agent output.\n     *\n     * If provided, output will be formatted to match the given schema and returned in the 'structuredResponse' state key.\n     * If not provided, `structuredResponse` will not be present in the output state.\n     *\n     * Can be passed in as:\n     *   - Zod schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: z.object({\n     *         capital: z.string(),\n     *       }),\n     *       // ...\n     *     });\n     *     ```\n     *   - JSON schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: {\n     *         type: \"json_schema\",\n     *         schema: {\n     *           type: \"object\",\n     *           properties: {\n     *             capital: { type: \"string\" },\n     *           },\n     *           required: [\"capital\"],\n     *         },\n     *       },\n     *       // ...\n     *     });\n     *     ```\n     *   - Create React Agent ResponseFormat\n     *     ```ts\n     *     import { providerStrategy, toolStrategy } from \"langchain\";\n     *     const agent = createAgent({\n     *       responseFormat: providerStrategy(\n     *         z.object({\n     *           capital: z.string(),\n     *         })\n     *       ),\n     *       // or\n     *       responseFormat: [\n     *         toolStrategy({ ... }),\n     *         toolStrategy({ ... }),\n     *       ]\n     *       // ...\n     *     });\n     *     ```\n     *\n     * **Note**: The graph will make a separate call to the LLM to generate the structured response after the agent loop is finished.\n     * This is not the only strategy to get structured responses, see more options in [this guide](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/).\n     */\n    responseFormat?: ResponseFormatType;\n    /**\n     * Middleware instances to run during agent execution.\n     * Each middleware can define its own state schema and hook into the agent lifecycle.\n     *\n     * @see {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}\n     */\n    middleware?: readonly AgentMiddleware<any, any, any>[];\n    /**\n     * An optional name for the agent.\n     */\n    name?: string;\n    /**\n     * An optional description for the agent.\n     * This can be used to describe the agent to the underlying supervisor LLM.\n     */\n    description?: string;\n    /**\n     * Use to specify how to expose the agent name to the underlying supervisor LLM.\n     *   - `undefined`: Relies on the LLM provider {@link AIMessage#name}. Currently, only OpenAI supports this.\n     *   - `\"inline\"`: Add the agent name directly into the content field of the {@link AIMessage} using XML-style tags.\n     *       Example: `\"How can I help you\"` -> `\"<name>agent_name</name><content>How can I help you?</content>\"`\n     */\n    includeAgentName?: \"inline\" | undefined;\n    /**\n     * An optional abort signal that indicates that the overall operation should be aborted.\n     */\n    signal?: AbortSignal;\n    /**\n     * Determines the version of the graph to create.\n     *\n     * Can be one of\n     * - `\"v1\"`: The tool node processes a single message. All tool calls in the message are\n     *           executed in parallel within the tool node.\n     * - `\"v2\"`: The tool node processes a single tool call. Tool calls are distributed across\n     *           multiple instances of the tool node using the Send API.\n     *\n     * @default `\"v2\"`\n     */\n    version?: \"v1\" | \"v2\";\n};\n/**\n * Type helper to extract union type from an array of Zod schemas\n */\nexport type ExtractZodArrayTypes<T extends readonly InteropZodType<any>[]> = T extends readonly [InteropZodType<infer A>, ...infer Rest] ? Rest extends readonly InteropZodType<any>[] ? A | ExtractZodArrayTypes<Rest> : A : never;\nexport type WithStateGraphNodes<K extends string, Graph> = Graph extends StateGraph<infer SD, infer S, infer U, infer N, infer I, infer O, infer C> ? StateGraph<SD, S, U, N | K, I, O, C> : never;\n"],"mappings":";;;;;;;;;;;;KAWYqB,CAAAA,UAAWnB;AAAvB;AAIA;AAUA;AAA6B,UAVZoB,SAUY,CAAA,SAAA,OAAA,CAAA,CAAA;EAAA;;;EAWJ,EAAA,EAAA,MAAA;EAKbG;AAMZ;AAyBA;EAiBYI,KAAAA,EAlEDN,MAkEO;AAIlB;AAkBYQ,UAtFKP,YAAAA,CAsFY;EAAA,QAAA,EArFflB,WAqFe,EAAA;EAAA,aAAgCqB,CAAAA,EApFzCL,SAoFyCK,EAAAA;EAAM;;;;;;;;EAA+N,MAAGb,CAAAA,EA3ExRM,YA2EwRN;;;;;AAAkFH,KAtE3Wc,SAAAA,GAsE2Wd;EAAY,QAA4CqB,EArEjavB,QAqEiauB;CAAsB;;;;AA8C3ab,UA9GTO,UAAAA,CA8GSP;EAAU;;;EAgDf,EAAA,EAsDAe,MAAAA;EAAkB;;AA2Bf;EAiBZE,IAAAA,EAAAA,MAAAA;EAAoB;;;EAA8C,IAAmBnC,EApPvF0B,MAoPuF1B,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA;EAAc;;;EAA2E,MAAwBqC,CAAAA,EAAAA,OAAAA;EAAI;;AAAK;EAC/ME,KAAAA,CAAAA,EAAAA,MAAAA;;;;;AAAyJG,UAxOpJf,UAAAA,CAwOoJe;EAAC;;;EAAU,EAAA,EAAEG,MAAAA;EAAC;;;EAAnB,MAAA,EAAA,GAAA;;;;;;;;;KAvNpJjB,MAAAA,sCAA4C1B;;;;UAIvC2B,gBAAAA;;;;;;;;QAQPH;;;;;;;;;;KAUEI,iDAAiDJ,sBAAsBA,2CAA2CV,oBAAoBjB,mBAAmBiB,wCAAwChB,eAAe+B,0BAA0B/B,4BAA4Ba,mBAAmBA,qBAAqBJ,iBAAiBE,kBAAkBoB,0BAA0BrB,aAAaqB,0BAA0BnB,iBAAiBmB,0BAA0BjB;;;;;;;;;;;;;;;;;;;;;;;;kBAwBrbV;;;;;;;;;;;;;;;;;;;;;;WAsBPa,aAAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAsCNc;;;;;iBAKD1B;;;;;UAKPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAsDS0B;;;;;;;wBAOKlB;;;;;;;;;;;;;;;;;;;;WAoBbmB;;;;;;;;;;;;;;;;;KAiBDC,wCAAwCnC,yBAAyBoC,oBAAoBpC,0CAA0CqC,sBAAsBrC,wBAAwBsC,IAAIH,qBAAqBE,QAAQC;KAC9MC,+CAA+CC,cAAcrC,6EAA6EA,WAAWsC,IAAIC,GAAGC,GAAGvB,IAAIwB,GAAGC,GAAGC,GAAGC"}